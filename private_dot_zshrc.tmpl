# shell options
setopt EXTENDED_HISTORY
setopt INC_APPEND_HISTORY
setopt SHARE_HISTORY

# history
HISTFILE=~/.zsh_history
HISTSIZE=10000000000000000
SAVEHIST=10000000000000000

# env
export EDITOR=vim
export NVM_DIR="$HOME/.nvm"

# aliases
alias l='exa -l'
alias rg='rg -p'
alias be='bundle exec'
alias paw="pwgen -snyc 128"
alias yt='uvx yt-dlp -f bestvideo+bestaudio --write-all-thumbnails --write-sub --convert-subs srt'
# /usr/local/bin/rsync -s -E -v -a -x --delete -l -u -H --exclude-from=$EXCLUDE -P -e ssh $SRC $DEST
alias f-rsync='rsync -s -E -v -a -x --delete -l -u -H -P'
alias my-rsync='rsync -avhzrXANteEgoD --fileflags'
alias cc-rsync='rsync -v -A -X -H -go --numeric-ids -D -l -rtpx -N --fileflags --force-change --protect-args --ignore-errors'
alias gc='git commit -m "up" && git push'
alias add='git add'
alias ci='git ci'
alias push='git push'
alias st='git status'

{{- if eq .chezmoi.os "darwin" }}

# completion
autoload -Uz compinit
compinit
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
autoload -U select-word-style
select-word-style bash

# env
export GOPATH=$HOME/go
export GOBIN=$GOPATH/bin
export BUN_INSTALL="$HOME/.bun"
export PYENV_ROOT="$HOME/.pyenv"
export DISABLE_SPRING=1
export OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES

# path
eval "$(/opt/homebrew/bin/brew shellenv)"
[[ -d $PYENV_ROOT/bin ]] && export PATH="$PYENV_ROOT/bin:$PATH"
export PATH=$PATH:$GOBIN
export PATH="$PATH:$HOME/.local/bin"
export PATH="$BUN_INSTALL/bin:$PATH"
export PATH="$HOME/.claude/local:$PATH"

# tool initializations
eval "$(rbenv init -)"
eval "$(pyenv init - zsh)"
eval "$(zoxide init zsh)"
source $HOME/.cargo/env

[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
[ -s "/opt/homebrew/opt/nvm/nvm.sh" ] && \. "/opt/homebrew/opt/nvm/nvm.sh"
[ -s "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm" ] && \. "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm"

# The next line updates PATH for the Google Cloud SDK.
if [ -f "$HOME/.local/google-cloud-sdk/path.zsh.inc" ]; then . "$HOME/.local/google-cloud-sdk/path.zsh.inc"; fi

# The next line enables shell command completion for gcloud.
if [ -f "$HOME/.local/google-cloud-sdk/completion.zsh.inc" ]; then . "$HOME/.local/google-cloud-sdk/completion.zsh.inc"; fi

# bun completions
[ -s "$HOME/.bun/_bun" ] && source "$HOME/.bun/_bun"

eval "$(uv generate-shell-completion zsh)"

_uv_run_mod() {
    if [[ "$words[2]" == "run" && "$words[CURRENT]" != -* ]]; then
        _arguments '*:filename:_files'
    else
        _uv "$@"
    fi
}

# aliases
# alias c="'/Applications/Cursor.app/Contents/MacOS/Cursor'"
alias code="'/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code'"
alias code2="'/Applications/Visual Studio Code - Insiders.app/Contents/Resources/app/bin/code'"
alias e='code'
# alias l='ls -lh'
alias less='less -RX'
alias ll='ls -A@cFl'

# functions
mupdate() {
  uv self update || return
  if whence -w backup >/dev/null 2>&1; then
    backup || return
  fi
  gcloud components update || return
  brew update && brew upgrade && brew cleanup --scrub --prune=all || return
  rustup update || return
  sudo softwareupdate -ir
}

# prompt
export PS1="%D{%H:%M:%S.%N%p %Z} %n@%B%m%b %d %# "

{{- else if eq .chezmoi.os "linux" }}

# completion
autoload -Uz vcs_info
zstyle ':vcs_info:*' formats '(%b)'

# env
# export GOPATH=$HOME/.local/go
# export CC="ccache gcc"
# export PSQL_HISTORY=/dev/null

# path
export PATH="$HOME/.local/go/bin:$PATH"
export PATH="$HOME/google-cloud-sdk/bin:$PATH"
export PATH="$PATH:$HOME/.local/bin:/snap/bin"
# export PATH="$HOME/bin:$PATH"

# tool initializations
# rbenv (lazy-loaded)
if [ -d "$HOME/.rbenv" ]; then
  export PATH="$HOME/.rbenv/bin:$HOME/.rbenv/shims:$PATH"
  _rbenv_load() {
    unset -f ruby gem bundle rbenv irb rake rails
    eval "$(~/.rbenv/bin/rbenv init - zsh)"
  }
  ruby() { _rbenv_load; ruby "$@"; }
  gem() { _rbenv_load; gem "$@"; }
  bundle() { _rbenv_load; bundle "$@"; }
  rbenv() { _rbenv_load; rbenv "$@"; }
  irb() { _rbenv_load; irb "$@"; }
  rake() { _rbenv_load; rake "$@"; }
  rails() { _rbenv_load; rails "$@"; }
fi

# nvm (lazy-loaded)
# Add default node to PATH for global npm binaries (codex, etc.)
if [ -d "$NVM_DIR/versions/node" ]; then
  _nvm_resolve_alias() {
    local alias="$1" target
    while [ -f "$NVM_DIR/alias/$alias" ]; do
      target=$(cat "$NVM_DIR/alias/$alias")
      [[ "$target" == v* ]] && { echo "$target"; return; }
      alias="$target"
    done
    # Check lts subdirectory
    [ -f "$NVM_DIR/alias/lts/$alias" ] && cat "$NVM_DIR/alias/lts/$alias" && return
    echo "$alias"
  }
  NODE_VER=$(_nvm_resolve_alias default)
  if [ -d "$NVM_DIR/versions/node/$NODE_VER" ]; then
    export PATH="$NVM_DIR/versions/node/$NODE_VER/bin:$PATH"
  else
    # Fallback: use latest installed version
    NODE_LATEST=$(ls -v "$NVM_DIR/versions/node" 2>/dev/null | tail -1)
    [ -n "$NODE_LATEST" ] && export PATH="$NVM_DIR/versions/node/$NODE_LATEST/bin:$PATH"
  fi
  unset -f _nvm_resolve_alias
fi
if [ -s "$NVM_DIR/nvm.sh" ]; then
  nvm() {
    unset -f nvm node npm npx
    \. "$NVM_DIR/nvm.sh"
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
    nvm "$@"
  }
  node() { unset -f nvm node npm npx; \. "$NVM_DIR/nvm.sh"; node "$@"; }
  npm() { unset -f nvm node npm npx; \. "$NVM_DIR/nvm.sh"; npm "$@"; }
  npx() { unset -f nvm node npm npx; \. "$NVM_DIR/nvm.sh"; npx "$@"; }
fi

# pyenv
eval "$(pyenv virtualenv-init -)"

# key bindings
bindkey -e
bindkey "^A" beginning-of-line
bindkey "^E" end-of-line

# aliases
alias ll='ls -AcFl'

# functions
# Clipboard (OSC 52 for remote, xclip/xsel for local)
osc52pbcopy() {
  local data esc
  data=$(cat | base64 | tr -d '\n')
  esc=$'\e]52;c;'$data$'\a'
  if [[ -n "$TMUX" ]]; then
    printf '\ePtmux;\e%s\e\\' "$esc" >/dev/tty
  else
    printf '%s' "$esc" >/dev/tty
  fi
}

osc52pbpaste() {
  printf '\e]52;c;?\a' >/dev/tty
  IFS=$'\a' read -rd '' _osc_reply || true
  printf '%s' "${_osc_reply#*52;c;}" | base64 --decode
}

_osc52_supported() {
  [[ "$TERM_PROGRAM" =~ ^(iTerm\.app|WezTerm)$ ]] || [[ "$TERM" == *kitty* ]] \
  || [[ "$TERM" == screen* ]] || [[ "$TERM" == tmux* ]]
}

if _osc52_supported; then
  alias pbcopy='osc52pbcopy'
  alias pbpaste='osc52pbpaste'
elif command -v xclip >/dev/null 2>&1; then
  alias pbcopy='xclip -selection clipboard'
  alias pbpaste='xclip -o -selection clipboard'
elif command -v xsel >/dev/null 2>&1; then
  alias pbcopy='xsel --clipboard --input'
  alias pbpaste='xsel --clipboard --output'
fi

mupdate() {
  sudo apt update && sudo apt -yu dist-upgrade || return
  sudo apt autoclean && sudo apt autoremove -y || return
  sudo apt-get remove -y --purge $(deborphan) 2>/dev/null
  sudo aptitude purge '~c' 2>/dev/null
  gcloud components update || return
  rustup upgrade && rustup update || return
  pyenv update || return
  uv self update || return
  rbenv update
}

# prompt
precmd() {
  vcs_info
  PS1="%(?..[%?] )%D{%H:%M:%S.%N%p %Z} %n@%B%m%b %~ ${vcs_info_msg_0_} %# "
}

{{- end }}

# local overrides
[[ -f "$HOME/.zshrc.local" ]] && source "$HOME/.zshrc.local"
[[ -f ~/.secrets ]] && source ~/.secrets
