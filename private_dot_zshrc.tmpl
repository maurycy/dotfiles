# shell options
setopt EXTENDED_HISTORY
setopt INC_APPEND_HISTORY
setopt SHARE_HISTORY
setopt NO_BEEP
setopt EXTENDED_GLOB

# deduplicate PATH
typeset -U path

# history
HISTFILE=~/.zsh_history
HISTSIZE=10000000000000000
SAVEHIST=10000000000000000

# env
export EDITOR=vim
export NVM_DIR="$HOME/.nvm"

# aliases
alias l='eza -l'
alias rg='rg -p'
alias be='bundle exec'
alias paw="pwgen -snyc 128"
alias yt='uvx yt-dlp -f bestvideo+bestaudio --write-all-thumbnails --write-sub --convert-subs srt'
# /usr/local/bin/rsync -s -E -v -a -x --delete -l -u -H --exclude-from=$EXCLUDE -P -e ssh $SRC $DEST
alias f-rsync='rsync -s -E -v -a -x --delete -l -u -H -P'
alias my-rsync='rsync -avhzrXANteEgoD --fileflags'
alias cc-rsync='rsync -v -A -X -H -go --numeric-ids -D -l -rtpx -N --fileflags --force-change --protect-args --ignore-errors'
alias add='git add'
alias ci='git ci'
alias push='git push'
alias pull='git pull'
alias st='git status'
alias cached='git diff --cached'

# nvm (lazy-loaded)
if [ -d "$NVM_DIR/versions/node" ]; then
  _nvm_resolve_alias() {
    local alias="$1" target
    while [ -f "$NVM_DIR/alias/$alias" ]; do
      target=$(cat "$NVM_DIR/alias/$alias")
      [[ "$target" == v* ]] && { echo "$target"; return; }
      alias="$target"
    done
    [ -f "$NVM_DIR/alias/lts/$alias" ] && cat "$NVM_DIR/alias/lts/$alias" && return
    echo "$alias"
  }
  NODE_VER=$(_nvm_resolve_alias default)
  if [ -d "$NVM_DIR/versions/node/$NODE_VER" ]; then
    export PATH="$NVM_DIR/versions/node/$NODE_VER/bin:$PATH"
  else
    NODE_LATEST=$(ls -v "$NVM_DIR/versions/node" 2>/dev/null | tail -1)
    [ -n "$NODE_LATEST" ] && export PATH="$NVM_DIR/versions/node/$NODE_LATEST/bin:$PATH"
  fi
  unset -f _nvm_resolve_alias
fi
if [ -s "$NVM_DIR/nvm.sh" ] || [ -s "/opt/homebrew/opt/nvm/nvm.sh" ]; then
  _nvm_load() {
    unset -f nvm node npm npx _nvm_load
    if [ -s "$NVM_DIR/nvm.sh" ]; then
      \. "$NVM_DIR/nvm.sh"
      [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
    elif [ -s "/opt/homebrew/opt/nvm/nvm.sh" ]; then
      \. "/opt/homebrew/opt/nvm/nvm.sh"
    fi
    [ -s "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm" ] && \. "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm"
  }
  nvm() { _nvm_load; nvm "$@"; }
  node() { _nvm_load; node "$@"; }
  npm() { _nvm_load; npm "$@"; }
  npx() { _nvm_load; npx "$@"; }
fi

# completion (cached for speed)
autoload -Uz compinit
if [[ -n ~/.zcompdump(#qN.mh+24) ]]; then
  compinit
else
  compinit -C
fi
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
autoload -U select-word-style
select-word-style bash

# prompt
autoload -Uz vcs_info
zstyle ':vcs_info:*' formats '(%b)'
precmd() {
  vcs_info
  PS1="%(?..[%?] )%D{%I:%M:%S.%N%p %Z} %n@%B%m%b %d ${vcs_info_msg_0_} %# "
}

{{- if eq .chezmoi.os "darwin" }}

# env
export GOPATH=$HOME/go
export GOBIN=$GOPATH/bin
export BUN_INSTALL="$HOME/.bun"
export PYENV_ROOT="$HOME/.pyenv"
export DISABLE_SPRING=1
export OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES

# path
# brew shellenv (cached for speed)
if [ -x /opt/homebrew/bin/brew ]; then
  _brew_cache="${XDG_CACHE_HOME:-$HOME/.cache}/zsh/brew_shellenv.zsh"
  if [[ ! -f "$_brew_cache" ]]; then
    mkdir -p "${_brew_cache:h}"
    /opt/homebrew/bin/brew shellenv > "$_brew_cache"
  fi
  source "$_brew_cache"
  unset _brew_cache
fi
[[ -d $PYENV_ROOT/bin ]] && export PATH="$PYENV_ROOT/bin:$PATH"
export PATH=$PATH:$GOBIN
export PATH="$PATH:$HOME/.local/bin"
export PATH="$BUN_INSTALL/bin:$PATH"
export PATH="$HOME/.claude/local:$PATH"

# tool initializations
command -v pyenv >/dev/null && eval "$(pyenv init - zsh)"
command -v zoxide >/dev/null && eval "$(zoxide init zsh)"
[ -f "$HOME/.cargo/env" ] && source "$HOME/.cargo/env"

# google cloud sdk
[ -f "$HOME/.local/google-cloud-sdk/path.zsh.inc" ] && . "$HOME/.local/google-cloud-sdk/path.zsh.inc"
[ -f "$HOME/.local/google-cloud-sdk/completion.zsh.inc" ] && . "$HOME/.local/google-cloud-sdk/completion.zsh.inc"

# bun completions
[ -s "$HOME/.bun/_bun" ] && source "$HOME/.bun/_bun"

# uv completion (cached for speed)
if command -v uv >/dev/null; then
  _uv_cache="${XDG_CACHE_HOME:-$HOME/.cache}/zsh/uv.zsh"
  _uv_ver="# $(uv --version)"
  if [[ ! -f "$_uv_cache" || "$_uv_ver" != "$(head -1 "$_uv_cache" 2>/dev/null)" ]]; then
    mkdir -p "${_uv_cache:h}"
    echo "$_uv_ver" > "$_uv_cache"
    uv generate-shell-completion zsh >> "$_uv_cache"
  fi
  source "$_uv_cache"
  unset _uv_cache _uv_ver
fi

# aliases
# alias c="'/Applications/Cursor.app/Contents/MacOS/Cursor'"
alias code="'/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code'"
alias code2="'/Applications/Visual Studio Code - Insiders.app/Contents/Resources/app/bin/code'"
alias e='code'
# alias l='ls -lh'
alias less='less -RX'
alias ll='ls -A@cFl'

{{- else if eq .chezmoi.os "linux" }}

# env
# export GOPATH=$HOME/.local/go
# export CC="ccache gcc"
# export PSQL_HISTORY=/dev/null

# path
export PATH="$HOME/.local/go/bin:$PATH"
export PATH="$HOME/google-cloud-sdk/bin:$PATH"
export PATH="$PATH:$HOME/.local/bin:/snap/bin"
# export PATH="$HOME/bin:$PATH"

# tool initializations
command -v pyenv >/dev/null && eval "$(pyenv virtualenv-init -)"

# key bindings
bindkey -e
bindkey "^A" beginning-of-line
bindkey "^E" end-of-line

# aliases
alias ll='ls -AcFl'

# functions
# Clipboard (OSC 52 for remote, xclip/xsel for local)
osc52pbcopy() {
  local data esc
  data=$(cat | base64 | tr -d '\n')
  esc=$'\e]52;c;'$data$'\a'
  if [[ -n "$TMUX" ]]; then
    printf '\ePtmux;\e%s\e\\' "$esc" >/dev/tty
  else
    printf '%s' "$esc" >/dev/tty
  fi
}

osc52pbpaste() {
  printf '\e]52;c;?\a' >/dev/tty
  IFS=$'\a' read -rd '' _osc_reply || true
  printf '%s' "${_osc_reply#*52;c;}" | base64 --decode
}

_osc52_supported() {
  [[ "$TERM_PROGRAM" =~ ^(iTerm\.app|WezTerm)$ ]] || [[ "$TERM" == *kitty* ]] \
  || [[ "$TERM" == screen* ]] || [[ "$TERM" == tmux* ]]
}

if _osc52_supported; then
  alias pbcopy='osc52pbcopy'
  alias pbpaste='osc52pbpaste'
elif command -v xclip >/dev/null 2>&1; then
  alias pbcopy='xclip -selection clipboard'
  alias pbpaste='xclip -o -selection clipboard'
elif command -v xsel >/dev/null 2>&1; then
  alias pbcopy='xsel --clipboard --input'
  alias pbpaste='xsel --clipboard --output'
fi

{{- end }}

# functions
_is_brew_pkg() {
  command -v brew >/dev/null && brew list "$1" &>/dev/null
}

mupdate() {
  command -v chezmoi >/dev/null && { chezmoi update || return; }
  command -v uv >/dev/null && { uv self update || return; }

  if whence -w backup >/dev/null 2>&1; then
    backup || return
  fi

  command -v gcloud >/dev/null && { gcloud components update || return; }

  if command -v brew >/dev/null; then
    brew update && brew upgrade && brew cleanup --scrub --prune=all || return
  fi

  if command -v apt >/dev/null; then
    sudo apt update && sudo apt -yu dist-upgrade || return
    sudo apt autoclean && sudo apt autoremove -y || return
    sudo apt-get remove -y --purge $(deborphan) 2>/dev/null
    sudo aptitude purge '~c' 2>/dev/null
  fi

  command -v rustup >/dev/null && { rustup update || return; }

  command -v pyenv >/dev/null && ! _is_brew_pkg pyenv && { pyenv update || true; }
  command -v rbenv >/dev/null && ! _is_brew_pkg rbenv && { rbenv update || true; }
  command -v bun >/dev/null && ! _is_brew_pkg bun && { bun upgrade || true; }

  command -v softwareupdate >/dev/null && sudo softwareupdate -ir
}

# rbenv (lazy-loaded)
if command -v rbenv >/dev/null 2>&1 || [ -d "$HOME/.rbenv" ]; then
  export RBENV_ROOT="${RBENV_ROOT:-$HOME/.rbenv}"
  export PATH="$RBENV_ROOT/bin:$RBENV_ROOT/shims:$PATH"
  _rbenv_load() {
    unset -f ruby gem bundle rbenv irb rake rails
    eval "$(rbenv init - zsh)"
  }
  ruby() { _rbenv_load; ruby "$@"; }
  gem() { _rbenv_load; gem "$@"; }
  bundle() { _rbenv_load; bundle "$@"; }
  rbenv() { _rbenv_load; rbenv "$@"; }
  irb() { _rbenv_load; irb "$@"; }
  rake() { _rbenv_load; rake "$@"; }
  rails() { _rbenv_load; rails "$@"; }
fi

# local overrides
[[ -f "$HOME/.zshrc.local" ]] && source "$HOME/.zshrc.local"
[[ -f ~/.secrets ]] && source ~/.secrets
